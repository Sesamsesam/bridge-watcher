# V1.5 Implementation Plan - Crash Recovery

**Status**: ðŸ“‹ PLANNED | **Target Lines**: ~150 additional (1100 total)

> V1.5 ensures the watcher can recover from crashes and handle orphaned tasks.

---

## Goals

1. **Lock TTL** - Expire stale locks after timeout
2. **Startup Sweep** - Detect and recover orphaned tasks
3. **Graceful Shutdown** - Clean up before exit
4. **Orphan Detection** - Tasks stuck in `running/` state

---

## Problem Statement

Currently, if the watcher crashes mid-task:

```
.ai-handoff/
â”œâ”€â”€ locks/__worker__.lock    # Stale lock (process dead)
â”œâ”€â”€ running/task-123.json    # Orphaned (no result written)
â””â”€â”€ tmp/ws-task-123/         # Abandoned worktree
```

The next watcher instance cannot start because the lock exists.

---

## Components to Build

### 1. Lock TTL (`src/watcher/lock.ts`)

**Add to existing lock module:**

```typescript
const DEFAULT_LOCK_TTL_MS = 30 * 60 * 1000; // 30 minutes

async function isLockExpired(lockPath: string, root: string): Promise<boolean>;
async function cleanupExpiredLock(lockPath: string, root: string): Promise<boolean>;
```

**Lines:** ~30 additional

---

### 2. Startup Sweep (`src/watcher/recovery.ts`)

**Purpose:** Run on startup to detect and handle orphaned tasks

```typescript
interface OrphanedTask {
  taskId: string;
  state: 'running' | 'locked';
  stuckSince: Date;
  worktreePath?: string;
}

async function detectOrphanedTasks(handoffPath: string): Promise<OrphanedTask[]>;
async function recoverOrphanedTask(orphan: OrphanedTask, handoffPath: string): Promise<void>;
async function runStartupSweep(handoffPath: string): Promise<void>;
```

**Recovery Actions:**
1. Move task from `running/` back to `tasks/` (will be retried)
2. Remove task lock if exists
3. Clean up worktree if exists
4. Log incident

**Lines:** ~80

---

### 3. Graceful Shutdown (`src/watcher/loop.ts`)

**Add signal handlers:**

```typescript
process.on('SIGINT', () => watcher.shutdown());
process.on('SIGTERM', () => watcher.shutdown());

async shutdown(): Promise<void> {
  this.running = false;
  // Wait for current task to finish
  // Release locks
  // Clean up temporary files
}
```

**Lines:** ~30

---

### 4. CLI Updates (`src/cli.ts`)

**Add recovery command:**

```bash
bridge recover --repo <path>   # Run startup sweep manually
```

**Lines:** ~15

---

## Execution Order

| Step | Component | Lines |
|------|-----------|-------|
| 1 | Lock TTL | ~30 |
| 2 | recovery.ts | ~80 |
| 3 | Graceful shutdown | ~30 |
| 4 | CLI update | ~15 |
| | **Total** | **~155** |

---

## Testing Strategy

### Harness Test: Crash Recovery

1. Create task file
2. Move task to `running/` (simulate mid-processing crash)
3. Create stale lock with old timestamp
4. Run `bridge run --single-pass`
5. Verify: task recovered, reprocessed, result written

---

## Verification Criteria

- [ ] Stale locks expire after TTL
- [ ] Orphaned tasks detected on startup
- [ ] Tasks in `running/` are recovered
- [ ] SIGINT/SIGTERM handled gracefully
- [ ] 7/7 harness tests pass (add crash recovery test)

---

## NOT in V1.5 (Deferred to V2)

- Extended secret patterns
- gitleaks integration
- Module refactoring

---

## Ready to Begin?

Review this plan, then say "Proceed with V1.5" to start implementation.
